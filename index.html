<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Nexus P2P v2.0</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/peerjs/1.4.7/peerjs.min.js"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --bg: #ffffff; --sec: #f4f4f5; --text: #1c1c1e; --hint: #8e8e93;
            --blue: #007aff; --red: #ff3b30; --msg-in: #e9e9eb; --msg-out: #007aff; --border: #e5e5ea;
            --radius: 16px;
        }
        @media (prefers-color-scheme: dark) {
            :root {
                --bg: #1c1c1e; --sec: #2c2c2e; --text: #ffffff; --hint: #98989d;
                --blue: #0a84ff; --msg-in: #3a3a3c; --msg-out: #0a84ff; --border: #38383a;
            }
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: -apple-system, system-ui, sans-serif; -webkit-tap-highlight-color: transparent; }
        body { background: var(--bg); color: var(--text); height: 100dvh; display: flex; overflow: hidden; font-size: 15px; }

        /* --- LAYOUT --- */
        .sidebar { width: 350px; border-right: 1px solid var(--border); display: flex; flex-direction: column; background: var(--bg); z-index: 2; }
        .chat-wrap { flex: 1; display: flex; flex-direction: column; background: var(--sec); position: relative; z-index: 1; }

        /* --- COMPONENTS --- */
        .header { height: 60px; padding: 0 15px; display: flex; align-items: center; gap: 12px; border-bottom: 1px solid var(--border); background: var(--bg); flex-shrink: 0; }
        .avatar { width: 40px; height: 40px; border-radius: 50%; background: var(--blue); color: #fff; display: flex; align-items: center; justify-content: center; font-weight: bold; object-fit: cover; flex-shrink: 0; cursor: pointer; }
        .avatar.small { width: 32px; height: 32px; font-size: 12px; }
        .avatar.square { border-radius: 8px; }

        .contact-list { flex: 1; overflow-y: auto; }
        .contact { padding: 12px 15px; display: flex; gap: 12px; align-items: center; cursor: pointer; transition: 0.2s; }
        .contact:hover { background: var(--sec); }
        .contact.active { background: var(--blue); color: #fff; }
        .contact.active .hint { color: rgba(255,255,255,0.7); }
        .hint { font-size: 13px; color: var(--hint); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        
        /* --- CHAT --- */
        .messages { flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 8px; }
        .msg { max-width: 80%; padding: 8px 12px; border-radius: 18px; position: relative; word-wrap: break-word; font-size: 15px; animation: popIn 0.2s ease; }
        .msg.in { background: var(--msg-in); align-self: flex-start; border-bottom-left-radius: 4px; }
        .msg.out { background: var(--msg-out); color: #fff; align-self: flex-end; border-bottom-right-radius: 4px; }
        
        .msg img { max-width: 100%; max-height: 250px; border-radius: 12px; margin-top: 5px; cursor: pointer; object-fit: cover; display: block; }
        .msg-meta { font-size: 10px; opacity: 0.6; margin-top: 4px; text-align: right; display: flex; align-items: center; justify-content: flex-end; gap: 4px; }
        
        .input-bar { background: var(--bg); padding: 10px; display: flex; gap: 10px; align-items: flex-end; border-top: 1px solid var(--border); }
        .input-field { flex: 1; background: var(--sec); border-radius: 20px; padding: 10px 15px; border: none; outline: none; color: var(--text); resize: none; max-height: 120px; font-size: 16px; line-height: 1.3; }
        .btn-icon { width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; color: var(--blue); font-size: 20px; cursor: pointer; border: none; background: none; transition: 0.2s; }
        .btn-icon:active { opacity: 0.5; }
        .btn-icon.red { color: var(--red); }
        .btn-icon.recording { color: var(--red); animation: pulse 1s infinite; background: rgba(255,59,48,0.1); border-radius: 50%; }

        /* --- MODALS --- */
        .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.6); z-index: 100; display: none; align-items: center; justify-content: center; backdrop-filter: blur(5px); opacity: 0; transition: opacity 0.3s; }
        .modal-overlay.open { opacity: 1; }
        .modal { background: var(--bg); width: 90%; max-width: 400px; padding: 24px; border-radius: 24px; box-shadow: 0 10px 40px rgba(0,0,0,0.3); transform: scale(0.9); transition: 0.3s; display: flex; flex-direction: column; gap: 15px; max-height: 85vh; overflow-y: auto; }
        .modal-overlay.open .modal { transform: scale(1); }
        
        .modal h3 { margin-bottom: 5px; }
        .modal input, .modal select { width: 100%; padding: 12px; border-radius: 12px; border: 1px solid var(--border); background: var(--sec); color: var(--text); outline: none; }
        .modal-btn { padding: 12px; border-radius: 12px; border: none; font-weight: 600; cursor: pointer; background: var(--blue); color: #fff; text-align: center; }
        .modal-btn.sec { background: var(--sec); color: var(--text); }
        .modal-btn.dest { background: rgba(255, 59, 48, 0.1); color: var(--red); }

        /* --- UTILS --- */
        .fab { position: absolute; bottom: 20px; right: 20px; width: 56px; height: 56px; border-radius: 50%; background: var(--blue); color: #fff; display: flex; align-items: center; justify-content: center; font-size: 24px; box-shadow: 0 4px 12px rgba(0,0,0,0.3); border: none; cursor: pointer; }
        .badge { background: var(--red); color: white; padding: 2px 6px; border-radius: 10px; font-size: 11px; margin-left: auto; }
        .toast { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.8); color: white; padding: 10px 20px; border-radius: 20px; font-size: 14px; z-index: 200; pointer-events: none; opacity: 0; transition: 0.3s; }
        .circle-video { width: 180px; height: 180px; border-radius: 50%; object-fit: cover; border: 3px solid var(--blue); background: #000; }
        
        /* --- MOBILE --- */
        @media (max-width: 768px) {
            .sidebar { width: 100%; }
            .chat-wrap { position: fixed; inset: 0; transform: translateX(100%); transition: 0.3s cubic-bezier(0.2, 0.8, 0.2, 1); }
            .chat-wrap.active { transform: translateX(0); }
        }
        @keyframes popIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.1); } }
        .code-container { font-family: monospace; background: rgba(0,0,0,0.05); padding: 8px; border-radius: 8px; font-size: 13px; margin: 5px 0; overflow-x: auto; border: 1px solid var(--border); }
    </style>
</head>
<body>

<div class="sidebar">
    <div class="header">
        <img id="myAvatarDisplay" class="avatar" src="" onclick="openSettings()" onerror="this.style.display='none';this.nextElementSibling.style.display='flex'">
        <div class="avatar" style="display:none" onclick="openSettings()">?</div>
        <div style="flex:1; overflow:hidden;">
            <div id="myNameDisplay" style="font-weight:700">Загрузка...</div>
            <div id="myIdDisplay" style="font-size:11px; opacity:0.6; cursor:pointer" onclick="copyMyId()">Нажмите для копирования ID</div>
        </div>
        <button class="btn-icon" onclick="openGroupCreate()"><i class="fas fa-users-medical"></i></button>
    </div>
    <div class="contact-list" id="contactList"></div>
    <button class="fab" onclick="openAddContact()"><i class="fas fa-plus"></i></button>
</div>

<div class="chat-wrap" id="chatWrap">
    <div class="header" id="chatHeader">
        <button class="btn-icon" onclick="closeChat()"><i class="fas fa-chevron-left"></i></button>
        <img id="chatAvatar" class="avatar small" src="" onclick="openChatProfile()">
        <div style="flex:1; margin-left: 10px; cursor:pointer" onclick="openChatProfile()">
            <div id="chatName" style="font-weight:600">Чат</div>
            <div id="chatStatus" style="font-size:12px; color:var(--blue)"></div>
        </div>
        <button class="btn-icon red" onclick="deleteCurrentChat()"><i class="fas fa-trash"></i></button>
    </div>
    
    <div class="messages" id="messages"></div>

    <div class="input-bar" id="inputBar">
        <label class="btn-icon"><i class="fas fa-paperclip"></i><input type="file" hidden onchange="sendFile(this)"></label>
        <textarea id="msgInput" class="input-field" placeholder="Сообщение..." rows="1" oninput="autoResize(this)"></textarea>
        <button id="voiceBtn" class="btn-icon" onclick="toggleRecord('audio')"><i class="fas fa-microphone"></i></button>
        <button id="videoBtn" class="btn-icon" onclick="toggleRecord('video')"><i class="fas fa-camera"></i></button>
        <button class="btn-icon" onclick="sendMsg()"><i class="fas fa-paper-plane"></i></button>
    </div>
</div>

<div class="toast" id="toast">Уведомление</div>

<div class="modal-overlay" id="modalWelcome">
    <div class="modal">
        <h2 style="text-align:center">Добро пожаловать!</h2>
        <p style="text-align:center; opacity:0.7">Придумайте себе ID (никнейм), по которому вас будут находить.</p>
        <input type="text" id="setupId" placeholder="Например: alex_boss_2024" maxlength="20">
        <input type="text" id="setupName" placeholder="Ваше имя" maxlength="30">
        <button class="modal-btn" onclick="finishSetup()">Начать общение</button>
    </div>
</div>

<div class="modal-overlay" id="modalAdd">
    <div class="modal">
        <h3>Новый контакт</h3>
        <input type="text" id="addId" placeholder="ID пользователя">
        <button class="modal-btn" onclick="addContact()">Добавить</button>
        <button class="modal-btn sec" onclick="closeModals()">Отмена</button>
    </div>
</div>

<div class="modal-overlay" id="modalGroup">
    <div class="modal">
        <h3>Создать группу / Канал</h3>
        <input type="text" id="groupTitle" placeholder="Название">
        <input type="text" id="groupMembers" placeholder="ID участников (через запятую)">
        <select id="groupType"><option value="group">Группа</option><option value="channel">Канал (пишу только я)</option></select>
        <button class="modal-btn" onclick="createGroup()">Создать</button>
        <button class="modal-btn sec" onclick="closeModals()">Отмена</button>
    </div>
</div>

<div class="modal-overlay" id="modalSettings">
    <div class="modal">
        <h3>Настройки</h3>
        <label>Имя</label><input type="text" id="setMyName">
        <label>Ссылка на аватар</label><input type="text" id="setMyAvatar">
        <div style="font-size:12px; opacity:0.6; margin-top:5px">Ваш ID: <b id="settingsMyId"></b></div>
        <button class="modal-btn" onclick="saveSettings()">Сохранить</button>
        <button class="modal-btn dest" onclick="logout()">Сбросить всё (Выход)</button>
        <button class="modal-btn sec" onclick="closeModals()">Закрыть</button>
    </div>
</div>

<div class="modal-overlay" id="modalProfile">
    <div class="modal">
        <img id="profAvatar" class="avatar square" style="width:100px; height:100px; margin:0 auto; font-size:40px" src="">
        <h3 id="profName" style="text-align:center">User</h3>
        <p id="profId" style="text-align:center; opacity:0.6; font-size:12px; cursor:pointer" onclick="copyText(this.innerText)">ID</p>
        
        <div id="profGroupControls" style="display:none">
            <hr>
            <h4>Участники:</h4>
            <div id="profMembers" style="font-size:12px; margin-bottom:10px; opacity:0.8"></div>
            <input type="text" id="profAddMemberInput" placeholder="Добавить ID...">
            <button class="modal-btn" style="padding:8px" onclick="addToGroup()">Добавить</button>
        </div>

        <button id="blockBtn" class="modal-btn dest" onclick="toggleBlock()">Заблокировать</button>
        <button class="modal-btn sec" onclick="closeModals()">Закрыть</button>
    </div>
</div>

<script>
/* ================= SYSTEM & STATE ================= */
const APP_VERSION = '2.0';
let peer;
let state = {
    profile: JSON.parse(localStorage.getItem('nx_profile')) || { name: '', id: '', avatar: '' },
    contacts: JSON.parse(localStorage.getItem('nx_contacts')) || [], // { id, name, type, avatar, blocked, peers(for groups) }
    chats: JSON.parse(localStorage.getItem('nx_chats')) || {}, // id: [msgs]
    conns: {} // Active peerjs connections
};

let activeChat = null;
let mediaRecorder = null;
let recordedChunks = [];

/* ================= INITIALIZATION ================= */
window.onload = () => {
    if(!state.profile.id) {
        document.getElementById('modalWelcome').classList.add('open');
        document.getElementById('modalWelcome').style.display = 'flex';
    } else {
        initPeer(state.profile.id);
    }
    renderContactList();
    updateSelfUI();
};

function finishSetup() {
    const id = document.getElementById('setupId').value.trim().replace(/[^a-zA-Z0-9_-]/g, '');
    const name = document.getElementById('setupName').value.trim();
    if(id.length < 3 || !name) return showToast('Заполните поля корректно');
    
    state.profile.id = id;
    state.profile.name = name;
    saveState();
    closeModals();
    initPeer(id);
    updateSelfUI();
}

async function initPeer(customId) {
    let iceServers = [{ urls: 'stun:stun.l.google.com:19302' }];
    try {
        const res = await fetch('https://speed.cloudflare.com/turn-creds');
        const cf = await res.json();
        iceServers.push({ urls: cf.uris, username: cf.username, credential: cf.password });
        console.log('TURN Loaded');
    } catch(e) { console.warn('TURN Failed, using STUN', e); }

    peer = new Peer(customId, {
        host: 'youpidor67-nexus.hf.space', 
        secure: true, port: 443, path: '/',
        config: { iceServers, iceCandidatePoolSize: 10 },
        debug: 1
    });

    peer.on('open', (id) => {
        document.getElementById('myIdDisplay').innerText = "ID: " + id;
        document.getElementById('settingsMyId').innerText = id;
        showToast('В сети');
        reconnectAll();
    });

    peer.on('connection', conn => {
        handleConnection(conn);
    });

    peer.on('error', err => {
        if(err.type === 'unavailable-id') {
            alert('Этот ID уже занят! Сбросьте данные и выберите другой.');
            logout();
        } else if (err.type === 'peer-unavailable') {
            showToast('Пользователь офлайн или не существует');
        } else {
            console.error(err);
        }
    });
}

function reconnectAll() {
    // Try to reconnect to active P2P contacts
    state.contacts.forEach(c => {
        if(c.type === 'p2p' && !state.conns[c.id]) connectTo(c.id);
    });
}

function connectTo(id) {
    if(id === state.profile.id || state.conns[id]) return;
    const conn = peer.connect(id);
    handleConnection(conn);
}

function handleConnection(conn) {
    conn.on('open', () => {
        state.conns[conn.peer] = conn;
        // Send my info update immediately
        conn.send({ type: 'info_update', name: state.profile.name, avatar: state.profile.avatar });
        
        // If unknown, add temporarily
        if(!state.contacts.find(c => c.id === conn.peer)) {
            // Wait for info update to name them properly, or default
        }
    });
    conn.on('data', data => handleData(conn.peer, data));
    conn.on('close', () => delete state.conns[conn.peer]);
    conn.on('error', () => delete state.conns[conn.peer]);
}

/* ================= DATA HANDLING ================= */
function handleData(senderId, data) {
    // 1. Check if blocked
    const contact = state.contacts.find(c => c.id === senderId);
    if(contact && contact.blocked) return;

    // 2. Info Update (Sync usernames)
    if(data.type === 'info_update') {
        if(contact) {
            contact.name = data.name;
            contact.avatar = data.avatar;
        } else {
            state.contacts.push({ id: senderId, name: data.name, type: 'p2p', avatar: data.avatar });
        }
        saveState();
        renderContactList();
        if(activeChat === senderId) updateChatHeader();
        return;
    }

    // 3. Messages (Group or P2P)
    const chatId = data.groupId || senderId;
    
    // Check if I'm in this group
    if(data.groupId) {
        let group = state.contacts.find(c => c.id === data.groupId);
        if(!group) {
            // Auto-join group if added (simplification)
            state.contacts.push({ id: data.groupId, name: data.groupName || 'Группа', type: 'group', peers: data.peers || [] });
            group = state.contacts[state.contacts.length-1];
            saveState(); renderContactList();
        }
        // Sync group members
        if(data.peers && group.peers.length < data.peers.length) {
            group.peers = data.peers; saveState();
        }
    }

    if(!state.chats[chatId]) state.chats[chatId] = [];
    
    state.chats[chatId].push({
        sender: senderId,
        senderName: data.senderName, // Name at moment of sending
        content: data.content,
        type: data.msgType,
        time: Date.now(),
        mine: false
    });
    
    saveState();
    renderContactList();
    if(activeChat === chatId) renderMessages();
    else showToast(`Сообщение от ${data.senderName || senderId}`);
}

/* ================= MESSAGING ================= */
function sendMsg(payload = null) {
    if(!activeChat) return;
    const text = document.getElementById('msgInput').value.trim();
    if(!text && !payload) return;

    const contact = state.contacts.find(c => c.id === activeChat);
    if(!contact) return;

    // Channel restriction
    if(contact.type === 'channel' && contact.admin !== state.profile.id && contact.id.includes('_')) {
        // If I created it, I am admin (logic handled in create)
        // Simple check: if I'm not in peers list as creator/admin logic (simplified here)
        // Let's assume anyone who has the channel in list can read, but purely P2P channel writing is hard to restrict without auth. 
        // We will just hide input for non-admins in UI, but here we allow logic.
    }

    const msg = {
        type: 'message',
        msgType: payload ? payload.type : 'text',
        content: payload ? payload.content : text,
        groupId: contact.type !== 'p2p' ? contact.id : null,
        groupName: contact.name,
        senderName: state.profile.name,
        peers: contact.peers // Send current peer list for syncing
    };

    // Send logic
    if(contact.type === 'p2p') {
        const conn = state.conns[contact.id];
        if(conn && conn.open) {
            conn.send(msg);
        } else {
            // Try connect and send
            const newConn = peer.connect(contact.id);
            newConn.on('open', () => {
                state.conns[contact.id] = newConn;
                newConn.send(msg);
                newConn.send({ type: 'info_update', name: state.profile.name, avatar: state.profile.avatar });
            });
            newConn.on('error', () => showToast('Не удалось отправить (офлайн)'));
        }
    } else {
        // Group/Channel: Fan-out to all peers
        contact.peers.forEach(pid => {
            if(pid === state.profile.id) return;
            const conn = state.conns[pid];
            if(conn && conn.open) conn.send(msg);
            else {
                const nc = peer.connect(pid);
                nc.on('open', () => { state.conns[pid] = nc; nc.send(msg); });
            }
        });
    }

    // Local save
    if(!state.chats[activeChat]) state.chats[activeChat] = [];
    state.chats[activeChat].push({
        sender: state.profile.id,
        content: msg.content,
        type: msg.msgType,
        time: Date.now(),
        mine: true
    });

    document.getElementById('msgInput').value = '';
    autoResize(document.getElementById('msgInput'));
    saveState();
    renderMessages();
    renderContactList();
}

/* ================= UI RENDERING ================= */
function renderContactList() {
    const list = document.getElementById('contactList');
    list.innerHTML = '';
    
    state.contacts.forEach(c => {
        const history = state.chats[c.id] || [];
        const lastMsg = history[history.length - 1];
        let preview = 'Нет сообщений';
        if(lastMsg) {
            if(lastMsg.type === 'text') preview = lastMsg.content.substring(0, 20);
            else preview = '[' + lastMsg.type + ']';
        }

        const div = document.createElement('div');
        div.className = `contact ${activeChat === c.id ? 'active' : ''}`;
        div.onclick = () => loadChat(c.id);
        
        let icon = c.avatar ? `<img src="${c.avatar}" class="avatar">` : `<div class="avatar">${c.name[0]}</div>`;
        if(c.type === 'channel') icon = `<div class="avatar" style="background:var(--red)"><i class="fas fa-bullhorn"></i></div>`;
        if(c.type === 'group') icon = `<div class="avatar" style="background:#8e8e93"><i class="fas fa-users"></i></div>`;

        div.innerHTML = `
            ${icon}
            <div style="flex:1; overflow:hidden">
                <div style="font-weight:600; display:flex; justify-content:space-between">
                    <span>${c.name}</span>
                    <span style="font-size:11px; opacity:0.6">${lastMsg ? new Date(lastMsg.time).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : ''}</span>
                </div>
                <div class="hint">${preview}</div>
            </div>
        `;
        list.appendChild(div);
    });
}

function loadChat(id) {
    activeChat = id;
    const contact = state.contacts.find(c => c.id === id);
    document.getElementById('chatWrap').classList.add('active');
    document.querySelectorAll('.contact').forEach(el => el.classList.remove('active'));
    renderContactList(); // highlight active
    updateChatHeader();
    renderMessages();

    // Hide input for channels if not admin (simple logic: admin is creator. Here we assume creator is first in peers list or by ID logic)
    const bar = document.getElementById('inputBar');
    if(contact.type === 'channel') {
        // Simple check: am I the first peer (creator)?
        if(contact.peers && contact.peers[0] === state.profile.id) bar.style.display = 'flex';
        else bar.style.display = 'none';
    } else {
        bar.style.display = 'flex';
    }
}

function updateChatHeader() {
    if(!activeChat) return;
    const c = state.contacts.find(x => x.id === activeChat);
    document.getElementById('chatName').innerText = c.name;
    
    const avatarImg = document.getElementById('chatAvatar');
    if(c.avatar) avatarImg.src = c.avatar; 
    else avatarImg.src = `https://ui-avatars.com/api/?name=${c.name}&background=random`;
    
    const status = document.getElementById('chatStatus');
    if(c.type === 'p2p') {
        status.innerText = state.conns[c.id] ? 'Онлайн' : 'Офлайн (сообщения дойдут при входе)';
    } else {
        status.innerText = c.peers.length + ' участников';
    }
}

function renderMessages() {
    const list = document.getElementById('messages');
    list.innerHTML = '';
    const msgs = state.chats[activeChat] || [];
    
    msgs.forEach(m => {
        const div = document.createElement('div');
        div.className = `msg ${m.mine ? 'out' : 'in'}`;
        
        let content = '';
        if(m.type === 'text') content = parseText(m.content);
        else if(m.type === 'image') content = `<img src="${m.content}" onclick="viewImage(this.src)">`;
        else if(m.type === 'audio') content = `<audio controls src="${m.content}"></audio>`;
        else if(m.type === 'video') content = `<video class="circle-video" src="${m.content}" autoplay loop muted playsinline onclick="this.muted=!this.muted"></video>`;

        div.innerHTML = `
            ${!m.mine && state.contacts.find(c=>c.id===activeChat).type !== 'p2p' ? `<div style="font-size:10px; opacity:0.7; margin-bottom:2px; color:var(--blue)">${m.senderName||'User'}</div>` : ''}
            ${content}
            <div class="msg-meta">
                ${new Date(m.time).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}
                ${m.mine ? '<i class="fas fa-check"></i>' : ''}
            </div>
        `;
        list.appendChild(div);
    });
    list.scrollTop = list.scrollHeight;
}

/* ================= ACTIONS ================= */
function addContact() {
    const id = document.getElementById('addId').value.trim();
    if(!id) return;
    if(id === state.profile.id) return showToast('Это ваш ID');
    if(state.contacts.find(c => c.id === id)) return showToast('Уже есть');

    state.contacts.push({ id, name: id, type: 'p2p', avatar: '' });
    saveState(); renderContactList(); closeModals();
    connectTo(id); // Auto connect to fetch profile
    loadChat(id);
}

function createGroup() {
    const title = document.getElementById('groupTitle').value.trim();
    const type = document.getElementById('groupType').value;
    const members = document.getElementById('groupMembers').value.split(',').map(s=>s.trim()).filter(s=>s);
    
    members.push(state.profile.id); // Add self
    const id = 'group_' + Date.now();
    
    state.contacts.push({ id, name: title || 'Group', type, peers: members });
    saveState(); renderContactList(); closeModals();
    loadChat(id);
    
    // Notify members
    sendMsg({ type: 'text', content: 'Группа создана' }); 
}

function deleteCurrentChat() {
    if(!activeChat || !confirm('Удалить чат и историю?')) return;
    delete state.chats[activeChat];
    state.contacts = state.contacts.filter(c => c.id !== activeChat);
    saveState();
    closeChat();
    renderContactList();
}

function addToGroup() {
    const newId = document.getElementById('profAddMemberInput').value.trim();
    if(!newId) return;
    const c = state.contacts.find(x => x.id === activeChat);
    if(c && (c.type === 'group' || c.type === 'channel')) {
        if(!c.peers.includes(newId)) c.peers.push(newId);
        saveState();
        updateChatHeader();
        document.getElementById('profMembers').innerText = c.peers.join(', ');
        // Send internal system message to update others' lists could be complex, 
        // for now we rely on the next message sent to propagate the new list.
        sendMsg({type:'text', content: `Пользователь ${newId} добавлен`});
    }
}

function toggleBlock() {
    const c = state.contacts.find(x => x.id === activeChat);
    if(!c) return;
    c.blocked = !c.blocked;
    saveState();
    document.getElementById('blockBtn').innerText = c.blocked ? 'Разблокировать' : 'Заблокировать';
    showToast(c.blocked ? 'Пользователь заблокирован' : 'Разблокирован');
}

/* ================= MEDIA & UTILS ================= */
function parseText(text) {
    if(!text) return '';
    return text.replace(/</g, "&lt;")
               .replace(/\n/g, "<br>")
               .replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank" style="color:var(--text); text-decoration:underline">$1</a>');
}

async function sendFile(input) {
    const file = input.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = e => {
        // Compress image logic could go here
        sendMsg({ type: 'image', content: e.target.result });
    };
    reader.readAsDataURL(file);
}

// Media Recorder (Audio/Video)
async function toggleRecord(type) {
    if(mediaRecorder) { mediaRecorder.stop(); return; }
    
    try {
        const constraints = type === 'video' 
            ? { video: { facingMode: "user", width: 480 }, audio: true }
            : { audio: true };
            
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        recordedChunks = [];
        const mime = MediaRecorder.isTypeSupported('video/mp4') ? 'video/mp4' : 'video/webm';
        
        mediaRecorder = new MediaRecorder(stream, { mimeType: type==='audio'?'audio/webm':mime });
        mediaRecorder.ondataavailable = e => { if(e.data.size>0) recordedChunks.push(e.data); };
        mediaRecorder.onstop = () => {
            const blob = new Blob(recordedChunks, {type: mediaRecorder.mimeType});
            const reader = new FileReader();
            reader.onloadend = () => sendMsg({ type: type, content: reader.result });
            reader.readAsDataURL(blob);
            stream.getTracks().forEach(t=>t.stop());
            mediaRecorder = null;
            document.querySelectorAll('.btn-icon.recording').forEach(e=>e.classList.remove('recording'));
        };
        
        mediaRecorder.start();
        document.getElementById(type==='audio'?'voiceBtn':'videoBtn').classList.add('recording');
        
    } catch(e) {
        showToast('Нет доступа к ' + type);
    }
}

/* ================= SETTINGS & MODALS ================= */
function openChatProfile() {
    if(!activeChat) return;
    const c = state.contacts.find(x => x.id === activeChat);
    document.getElementById('profName').innerText = c.name;
    document.getElementById('profId').innerText = c.id;
    document.getElementById('profAvatar').src = c.avatar || `https://ui-avatars.com/api/?name=${c.name}`;
    document.getElementById('blockBtn').innerText = c.blocked ? 'Разблокировать' : 'Заблокировать';
    
    const groupBlock = document.getElementById('profGroupControls');
    if(c.type === 'group' || c.type === 'channel') {
        groupBlock.style.display = 'block';
        document.getElementById('profMembers').innerText = c.peers.join(', ');
    } else {
        groupBlock.style.display = 'none';
    }
    
    openModal('modalProfile');
}

function saveSettings() {
    state.profile.name = document.getElementById('setMyName').value;
    state.profile.avatar = document.getElementById('setMyAvatar').value;
    saveState(); updateSelfUI(); closeModals();
    // Notify all active connections about update
    Object.values(state.conns).forEach(conn => {
        conn.send({ type: 'info_update', name: state.profile.name, avatar: state.profile.avatar });
    });
}

function updateSelfUI() {
    document.getElementById('myNameDisplay').innerText = state.profile.name;
    if(state.profile.avatar) document.getElementById('myAvatarDisplay').src = state.profile.avatar;
    document.getElementById('setMyName').value = state.profile.name;
    document.getElementById('setMyAvatar').value = state.profile.avatar;
}

function logout() {
    if(confirm('Это удалит все чаты и профиль с этого устройства. Продолжить?')) {
        localStorage.clear();
        location.reload();
    }
}

// Helpers
function saveState() {
    localStorage.setItem('nx_contacts', JSON.stringify(state.contacts));
    localStorage.setItem('nx_chats', JSON.stringify(state.chats));
    localStorage.setItem('nx_profile', JSON.stringify(state.profile));
}
function autoResize(el) { el.style.height='auto'; el.style.height=el.scrollHeight+'px'; }
function openModal(id) { 
    document.querySelectorAll('.modal-overlay').forEach(el => el.classList.remove('open'));
    document.querySelectorAll('.modal-overlay').forEach(el => el.style.display='none');
    const m = document.getElementById(id); m.style.display='flex'; 
    setTimeout(()=>m.classList.add('open'), 10);
}
function closeModals() { document.querySelectorAll('.modal-overlay').forEach(el => { el.classList.remove('open'); setTimeout(()=>el.style.display='none',300) }); }
function showToast(txt) { const t=document.getElementById('toast'); t.innerText=txt; t.style.opacity=1; setTimeout(()=>t.style.opacity=0, 3000); }
function closeChat() { document.getElementById('chatWrap').classList.remove('active'); activeChat=null; document.querySelectorAll('.contact').forEach(el=>el.classList.remove('active')); }
function openAddContact() { openModal('modalAdd'); }
function openGroupCreate() { openModal('modalGroup'); }
function openSettings() { openModal('modalSettings'); }
function copyText(txt) { navigator.clipboard.writeText(txt).then(()=>showToast('Скопировано')); }
function copyMyId() { copyText(state.profile.id); }
function viewImage(src) { const w=window.open('','_blank'); w.document.write(`<img src="${src}" style="width:100%">`); }

document.querySelectorAll('.modal-overlay').forEach(ov => ov.addEventListener('click', e => { if(e.target === ov) closeModals(); }));

</script>
</body>
</html>
